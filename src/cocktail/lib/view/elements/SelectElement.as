/*	****************************************************************************
		Cocktail ActionScript Full Stack Framework. Copyright (C) 2009 Codeine.
	****************************************************************************
   
		This library is free software; you can redistribute it and/or modify
	it under the terms of the GNU Lesser General Public License as published
	by the Free Software Foundation; either version 2.1 of the License, or
	(at your option) any later version.
		
		This library is distributed in the hope that it will be useful, but
	WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
	or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
	License for more details.

		You should have received a copy of the GNU Lesser General Public License
	along with this library; if not, write to the Free Software Foundation,
	Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

	-------------------------
		Codeine
		http://codeine.it
		contact@codeine.it
	-------------------------
	
*******************************************************************************/

package cocktail.lib.view.elements {	import cocktail.core.connectors.MotionConnector;	import cocktail.core.data.dao.ProcessDAO;	import cocktail.core.data.dao.layout.LayoutOptionDAO;	import cocktail.core.data.dao.layout.LayoutSelectDAO;	import cocktail.core.data.dao.style.StyleBtnDAO;	import cocktail.core.data.dao.style.StyleDAO;	import cocktail.core.data.dao.style.StyleSelectDAO;	import cocktail.lib.Controller;	import cocktail.lib.View;	import cocktail.lib.view.elements.Element;		import org.hasseg.externalMouseWheel.ExternalMouseWheelSupport;		import flash.display.Sprite;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Rectangle;	import flash.text.TextFieldAutoSize;	import flash.utils.Timer;		/**	 * Cocktail base class for select/dropdowns.	 * @author nybras | nybras@codeine.it	 * @see	OptionElement	 */	public class SelectElement extends Element 	{		/* ---------------------------------------------------------------------			VARS		--------------------------------------------------------------------- */				private var _wheel : ExternalMouseWheelSupport;		private var _scroll_pos : Number = 0;				private var _style : StyleSelectDAO;		private var _info : LayoutSelectDAO;		private var _dispatcher : EventDispatcher;				private var _options : Array;		private var _options_proxies : Array;				private var _selected : OptionElement;		private var _open : Boolean;				private var _display_btn : BtnElement;//		private var _display_arrow_up : SwfElement;//		private var _display_arrow_down : SwfElement;		private var _display_txt : TxtElement;				private var _options_motion : MotionConnector;		private var _options_sprite : Sprite;				private var _scroll : Sprite;		private var _scroll_track : Sprite;		private var _scroll_slider : Sprite;		private var _scroll_motion : MotionConnector;				private var _scroller : Timer;				private var _has_scroll : Boolean;				private var _list_x : uint;		private var _list_y : uint;		private var _list_width : uint;		private var _list_height : uint;		private var _list_orig_height : uint;								/* ---------------------------------------------------------------------			LOADING		--------------------------------------------------------------------- */				/**		 * Invoked before load.		 */		public function before_load () : void		{			_wheel = ExternalMouseWheelSupport.getInstance( sprite.stage );			build();		}								/* ---------------------------------------------------------------------			RENDERING		--------------------------------------------------------------------- */				/**		 * Invoked before render.		 */		override public function before_render () : void		{			var option : OptionElement;						super.before_render();						_options_sprite.alpha = 0;			_options_sprite.visible = false;						_display_btn.draw( _style );						if ( _style.bg_width || _style.bg_height )				_display_txt.field.autoSize = TextFieldAutoSize.NONE;						if ( _style.bg_width )				_display_txt.field.width = _style.bg_width;							if ( _style.bg_height )				_display_txt.field.height = _style.bg_height;						_display_txt.field.mouseEnabled = false;						if ( _style.font )				_display_txt.format( _style.font , _style.font_size, _style.color, _style.text_align, _style.underline );						if ( _info.label != null )				_display_txt.text = _info.label;			else if ( selected is OptionElement )				_display_txt.text = label;			else if ( ( option = _options[ 0 ] ) is OptionElement )				_display_txt.text = option.label;						_display_btn.sprite.addEventListener( MouseEvent.CLICK, display_click, false, 0, true );						// mouse wheel activte/deactivate 			sprite.addEventListener( MouseEvent.MOUSE_OVER, start_wheel, false, 0, true );			sprite.addEventListener( MouseEvent.MOUSE_OUT, stop_wheel, false, 0, true );						sprite.stage.addEventListener( MouseEvent.MOUSE_DOWN , auto_collapse, false, 0, true );		}		//		override public function after_render () : void//		{//			_display_arrow_up.sprite.rotation = 90;//			_display_arrow_up.sprite.scaleX = //			_display_arrow_up.sprite.scaleY = .25;//			//			_display_arrow_down.sprite.rotation = -90;//			_display_arrow_down.sprite.scaleX = //			_display_arrow_down.sprite.scaleY = .25;//			//			_display_arrow_up.sprite.x = ( _display_btn.sprite.width - _display_arrow_down.sprite.width ) - 5;//			_display_arrow_down.sprite.x = ( ( _display_btn.sprite.width - _display_arrow_down.sprite.width ) - 11.5 ); //			//			_display_arrow_up.sprite.y = 1;//			_display_arrow_down.sprite.y = 15;//			//			super.after_render();//		}								/**		 * Realigns all options with snap=0 1.		 */		public function snap_childs ( ...params ) : void		{			var option : OptionElement;						for ( var i : uint = 0; i < _options.length; i++ )			{				option = _options[ i ];				option.sprite.y = option.sprite.height + ( option.sprite.height * i );			}		}								/* ---------------------------------------------------------------------			DESTROYING		--------------------------------------------------------------------- */				/**		 * Invoked before destroy.		 */		public function before_destroy ( dao : ProcessDAO ) : void		{			dao;			_wheel.closeJSConnection();		}						/* ---------------------------------------------------------------------			HIGHLIGHT		--------------------------------------------------------------------- */				/**		 * Turns highlight on or off.		 */		public function highlight ( on : Boolean = true ) : void		{			if ( on )			{				_style.border = true;				_style.border_color = 0xff0000;			} else				_style.border = false;						_display_btn.draw( _style );		}		
		
		
		/* ---------------------------------------------------------------------			BUILDER		--------------------------------------------------------------------- */				/**		 * Build the select.		 */		private function build () : void		{			var child : View;						// style + info			_style = style() as StyleSelectDAO;			_info = ( this.info as LayoutSelectDAO );						// vars			_options = [];			_options_proxies = [];			_dispatcher = new EventDispatcher();						// dropdown container			_options_sprite = new Sprite( );			sprite.addChild( _options_sprite );			_options_motion = new MotionConnector( _options_sprite );						// btn				_display_btn = addChild( create ( <btn /> ), true ) as BtnElement;			_display_btn.sprite.mouseChildren = true;			_display_txt = _display_btn.addChild( create( <txt>select</txt> ) ) as TxtElement;//			_display_arrow_up = SwfElement ( _display_btn.addChild( create( <swf shared="true" src="buttons/leftArrow.swf" /> ) ) );//			_display_arrow_down = SwfElement ( _display_btn.addChild( create( <swf shared="true" src="buttons/leftArrow.swf" /> ) ) );						// scroll			_scroll = new Sprite( );						_scroll.addChild( _scroll_track = new Sprite() );			_scroll.addChild( _scroll_slider = new Sprite() );			_scroll_motion = new MotionConnector ( _scroll );						sprite.addChild( _scroll );						_scroller = new Timer ( 30, 0 );			_scroller.addEventListener( TimerEvent.TIMER , scroll );						// catching xml items			for each ( child in childs() )				if ( child is OptionElement )					_add ( child as OptionElement );		}								/* ---------------------------------------------------------------------			SCROLL		--------------------------------------------------------------------- */				/**		 * Build the scroll.		 */		private function refresh () : void		{			var option : OptionElement;						_has_scroll = ( _info.size && _info.size < _options.length );						// clearing			_scroll_slider.graphics.clear();			_scroll_track.graphics.clear();			_scroll_slider.buttonMode = false;						// reseting listeners			_scroll_slider.removeEventListener( MouseEvent.MOUSE_DOWN , slider_down );			_scroll_slider.removeEventListener( MouseEvent.MOUSE_UP , slider_up );			sprite.stage.removeEventListener( MouseEvent.MOUSE_UP , slider_up );			sprite.removeEventListener( MouseEvent.MOUSE_WHEEL, scroll_wheel );						// rect mask			_options_sprite.scrollRect = null;						// properties			if ( _has_scroll )			{				option = ( _options[ 0 ] as OptionElement );								_list_x = _display_btn.sprite.x;				_list_y = _display_btn.sprite.y + _display_btn.sprite.height;								_list_width = option.sprite.width;				_list_height = option.sprite.height * _info.size;								_list_orig_height = _options_sprite.transform.pixelBounds.height;				_options_sprite.y = _list_y;								// positioning				_scroll.x = _list_width;				_scroll.y = _list_y;								// drawning				_scroll_track.graphics.beginFill( 0x666666, 1 );				_scroll_track.graphics.drawRect( 0, 0, 15, _list_height );								_scroll_slider.graphics.beginFill( 0x222222, 1 );				_scroll_slider.graphics.drawRect( 0, 0, 15, ( _list_height * ( _info.size / _options.length ) ) );								// content mask				_options_sprite.scrollRect = new Rectangle ( _list_x, _list_y , _list_width , _list_height );								// triggers				_scroll_slider.buttonMode = true;				_scroll_slider.addEventListener( MouseEvent.MOUSE_DOWN , slider_down, false, 0, true );				_scroll_slider.addEventListener( MouseEvent.MOUSE_UP , slider_up, false, 0, true );				sprite.stage.addEventListener( MouseEvent.MOUSE_UP , slider_up, false, 0, true );				sprite.addEventListener( MouseEvent.MOUSE_WHEEL, scroll_wheel, false, 0, true );			}		}								/**		 * Slider click trigger.		 * @param event	MouseEvent.MOUSE_DOWN. 		 */		private function slider_down ( event : MouseEvent ) : void		{			var bounds : Rectangle;						bounds = new Rectangle(				_scroll_track.x,				_scroll_track.y,				_scroll_track.x,				( _scroll_track.height - _scroll_slider.height )			);						scroll();			_scroller.start();			_scroll_slider.startDrag( false , bounds );		}				/**		 * Slider release trigger.		 * @param event	MouseEvent.MOUSE_UP. 		 */		private function slider_up ( event : MouseEvent ) : void		{			_scroller.stop();			_scroll_slider.stopDrag();		}								/**		 * Scrolls the select to the given percent.		 * @param percent	Percent to scroll ( 0 ~ 1)		 * @param event	MouseEvent.MOUSE_MOVE.		 */		private function scroll ( event : TimerEvent = null, percent : Number = undefined ) : void		{			var moveslider : Boolean;			var scroller : Rectangle;						moveslider = ! isNaN ( percent );						if ( ! moveslider )				percent = ( _scroll_slider.y / ( _scroll_track.height - _scroll_slider.height ) );						percent = ( percent > 1 ? 1 : percent < 0 ? 0 : percent );						if ( moveslider )				_scroll_slider.y = ( _scroll_track.y + ( percent * ( _scroll_track.height - _scroll_slider.height ) ) );						scroller = _options_sprite.scrollRect;			scroller.y = _list_y + ( percent * ( _list_orig_height - _list_height ) );//			//			trace ( "-----" );//			trace ( "PERCENT: "+ percent );//			trace ( "SCROLL: "+ scroller.y );//			trace ( "HEIGHT: " + _list_height );//			trace ( "ORIG_HEIGHT: " + _list_orig_height );						_options_sprite.scrollRect = scroller;						_scroll_pos = percent;		}				/**		 * Mouse wheel handler for scroll.		 * @param event	MouseEvent.MOUSE_WHEEL.		 */
		public function scroll_wheel ( event : MouseEvent ) : void		{			scroll ( null, ( _scroll_pos + ( ( event.delta / 100 ) * -1 ) ) );		}								/* ---------------------------------------------------------------------			GETTERS		--------------------------------------------------------------------- */				/**		 * Gets the selected item.		 * @return	The selected OptionElement.		 */		public function get selected () : OptionElement		{			return _selected;		}				/**		 * Sets the selected item.		 * @param option	The OptionElement (or its label or value) to set as selected.		 */		public function set selected ( option : * ) : void		{			var tmp_option : OptionElement;			var tmp_selected : OptionElement;			var event : Event;						if ( option is OptionElement )				tmp_selected = option;			else				for each ( tmp_option in _options )				{				if ( tmp_option.label == option || tmp_option.value == option )						tmp_selected = tmp_option;				}						if ( tmp_selected == _selected )				return;						_selected = tmp_selected;			_selected.over();						_display_txt.text = _selected.label;						event = new Event( Event.CHANGE );			_dispatcher.dispatchEvent( event );		}								/**		 * Gets the selected item value.		 * @return	The selected OptionElement value.		 */		public function get value () : String		{			if ( _selected )				return selected.value;						return null;		}				/**		 * Gets the selected item label.		 * @return	The selected OptionElement label.		 */		public function get label () : String		{			if ( _selected )				return selected.label;						return null;		}				/**		 * Sets the selected item label.		 * @param label	The desired label.		 */		public function set label ( label : String ) : void		{			_display_txt.text = label;		}								/* ---------------------------------------------------------------------			TRIGGERING		--------------------------------------------------------------------- */				/**		 * Sets all triggers.		 */		private function set_triggers ( option : OptionElement ) : void		{			var over : Function;			var out : Function;			var click : Function;						for each ( option in _options )			{				_options_proxies.push ( {					click: click = proxy( option_click, option ),					option : option				});								option.sprite.addEventListener( MouseEvent.CLICK, click );				option.sprite.mouseEnabled = false;			}		}				/**		 * Options click trigger.		 * @param option	Option element ( event target view ).		 * @param event	MouseEvent.CLICK.		 */		private function option_click ( option : OptionElement, event : MouseEvent ) : void		{			selected = option;			collapse();		}				/**		 * Select click trigger.		 * @param event	MouseEvent.CLICK.		 */		private function display_click ( event : MouseEvent ) : void		{			var up : View;			var self : View;						up = this.up;			self = this;						while ( up != null )			{				up.sprite.addChild( self.sprite );				self = up;				up = up.up;			}						( _open ? collapse( ) : expand () );		}								/* **********************		 * mouse wheel triggers.		 * **********************		 */				/**		 * Start the wheel hack connection		 * @param event	MouseEvent.MOUSE_OVER.		 */		private function start_wheel ( event : MouseEvent ) : void		{			if ( _selected is OptionElement )				_selected.out();						if ( _has_scroll )				_wheel.initJSConnection();		}				/**		 * Stop the wheel hack connection.		 * @param event	MouseEvent.MOUSE_OUT.		 */		private function stop_wheel ( event : MouseEvent ) : void		{			if ( _selected is OptionElement )				_selected.over();						if ( _has_scroll )				_wheel.closeJSConnection();		}								/* ---------------------------------------------------------------------			EXPAND / COLLAPSE		--------------------------------------------------------------------- */				/**		 * Expands the select options.		 */		private function expand () : void		{			var i : Number;			var option : OptionElement;						if ( _open )				return;						for ( i = 0; i < _options.length; i++ )			{				option = _options[ i ];				option.sprite.mouseEnabled = true;//				option.motion.alpha( 1, .5, ( i * .05 ) );			}						snap_childs();			refresh();						_options_sprite.visible = true;			_options_sprite.alpha = 0;			_options_motion.alpha ( 1, .5 );						// _options_motion.alpha ( 1, .5 );						if ( _has_scroll )			{				_scroll.visible = true;				_scroll_motion.alpha( 1, .5 );//				_scroll_motion.alpha( 1, ( .5 + ( _info.size * .05 ) ) );			}						if ( _selected is OptionElement )				_selected.over();						_open = true;		}				/**		 * Collapse the select options.		 */		private function collapse () : void		{			var i : Number;			var option : OptionElement;						if ( ! _open )				return;						for ( i = _options.length; --i >= 0; )			{				option = _options[ i ];				option.sprite.mouseEnabled = false;//				if ( i == 0 )//					option.motion.alpha( 0, .3 , ( ( _options.length - ( i + 1 ) ) * .03 ) ).listen( invisible );//				else//					option.motion.alpha( 0, .3 , ( ( _options.length - ( i + 1 ) ) * .03 ) );			}						_options_motion.alpha( 0, .5 ).listen( invisible );						if ( _has_scroll )			{				_scroll_motion.alpha( 0, .5 );				scroll( null, 0 );			}//				_scroll_motion.alpha( 0, ( .3 + ( _info.size * .03 ) ) );						_open = false;		}				/**		 * After collapsed, make all options invisible.		 * @param event	Event.COMPLETE.		 */		private function invisible ( event : Event ) : void		{//			var option : OptionElement;			//			for each ( option in _options )//				option.sprite.visible = false;			_options_sprite.visible = false;						if ( _has_scroll )			{				_scroll.visible = false;				scroll ( null, 0 );			}		}		/**		 * Checks when mouse is down but not over the select area, and collapse it.		 * @param params	MouseEvent.CLICK		 */		private function auto_collapse ( event : MouseEvent ) : void		{			if ( ! sprite.hitTestPoint( ctrl.stage.mouseX , ctrl.stage.mouseY ) )				collapse();		}								/* ---------------------------------------------------------------------			LISTENING		--------------------------------------------------------------------- */				/**		 * Start listening events.		 * @param change	Change listener.		 */		public function listen ( change : Function ) : void		{			_dispatcher.addEventListener( Event.CHANGE , change );		}				/**		 * Stop listening events.		 * @param change	Change listener.		 */		public function unlisten ( change : Function ) : void		{			_dispatcher.removeEventListener( Event.CHANGE , change );		}
										/**		 * 		 */		private function _add ( option : OptionElement ) : OptionElement
		{			// swapping sprite containers			sprite.removeChild( option.sprite );			_options_sprite.addChild( option.sprite );						// reseting x/y			option.sprite.x = 0;			option.sprite.y = 0;						// keeping options and checking selected			_options.push ( option );						set_triggers( option );						try {				if ( ( option.info as LayoutOptionDAO ).selected )					selected = option;			} catch ( e : Error ) 			{			}						return option;		}
						/**		 * 		 */		public function add ( node : XML ) : OptionElement		{			return _add ( addChild ( create ( node ) ) as OptionElement ); 		}								/**		 * 		 */		public function clear () : void
		{			var item : *;			var option : OptionElement;						for each ( item in _options_proxies )			{				option = item[ "option" ];				option.sprite.removeEventListener( MouseEvent.CLICK , item[ "click" ] );								if ( option.sprite.parent )					option.sprite.parent.removeChild( option.sprite );			}						_options = [];			_options_proxies = [];						_selected = null;			_display_txt.text = ( _info.label ? _info.label : "" );						refresh();		}	}}